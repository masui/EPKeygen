// Generated by CoffeeScript 1.12.7
var charkind, charset, crypt, crypt_char, hexcharset, origcharset, utf2bytestr;

origcharset = ['abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', '0123456789', '-', '~!@#$%^&*()_=+[{]}|;:.,#?', ' ', "\"'/<>\\`"];

hexcharset = ["0123456789abcdef"];

charset = origcharset;

charkind = function(c) {
  var ind, k, ref, results;
  ind = null;
  (function() {
    results = [];
    for (var k = 0, ref = charset.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    if (charset[i].indexOf(c) >= 0) {
      return ind = i;
    }
  });
  return ind;
};

crypt_char = function(c, n) {
  var chars, cind, ind, kind, len;
  kind = charkind(c);
  chars = charset[kind];
  cind = chars.indexOf(c);
  len = chars.length;
  ind = (n - cind + len) % len;
  return chars[ind];
};

utf2bytestr = function(text) {
  var k, ref, result, results;
  result = "";
  if (text === null) {
    return result;
  }
  (function() {
    results = [];
    for (var k = 0, ref = text.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    var c;
    c = text.charCodeAt(i);
    if (c <= 0x7f) {
      return result += String.fromCharCode(c);
    } else {
      if (c <= 0x07ff) {
        result += String.fromCharCode(((c >> 6) & 0x1F) | 0xC0);
        return result += String.fromCharCode((c & 0x3F) | 0x80);
      } else {
        result += String.fromCharCode(((c >> 12) & 0x0F) | 0xE0);
        result += String.fromCharCode(((c >> 6) & 0x3F) | 0x80);
        return result += String.fromCharCode((c & 0x3F) | 0x80);
      }
    }
  });
  return result;
};

crypt = function(seed, secret_string) {
  var hash, k, ref, res, results;
  if (seed.match(/[0-9a-f]{32}/) && seed.match(/[a-f]/) && seed.match(/[0-9]/)) {
    charset = hexcharset;
  } else {
    charset = origcharset;
  }
  hash = exports.MD5_hexhash(utf2bytestr(secret_string));
  res = '';
  (function() {
    results = [];
    for (var k = 0, ref = seed.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).forEach(function(i) {
    var j, n, s;
    j = i % 8;
    s = hash.substring(j * 4, j * 4 + 4);
    n = parseInt(s, 16);
    return res += crypt_char(seed[i], n + i);
  });
  return res;
};

exports.crypt = crypt;

